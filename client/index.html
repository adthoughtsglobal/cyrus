<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Peer Client</title>
  <script src="../scripts/reqs.js"></script>
  <style>
    body {
      font-family: sans-serif;
    }

    #files {
      border: 1px solid #ccc;
      padding: 8px;
      max-width: 400px;
    }

    .file {
      display: flex;
      justify-content: space-between;
      padding: 4px;
      cursor: pointer;
    }

    .file:hover {
      background: #eee;
    }

    small {
      color: #666;
    }
  </style>
</head>

<body>

  <div id="status">idle</div>

  <h3>Files</h3>
  <div id="files"></div>

  <pre id="log" style="height:160px;overflow:auto;border:1px solid #ccc"></pre>

  <script>
    const statusEl = document.getElementById('status')
    const logEl = document.getElementById('log')
    const filesEl = document.getElementById('files')

    const status = s => statusEl.textContent = s
    const log = (...a) => {
      logEl.textContent += a.join(' ') + '\n'
      logEl.scrollTop = logEl.scrollHeight
    }

    let peer, conn
    let hostId = localStorage.getItem('hostPeerId')
    let clientId = localStorage.getItem('client_id') || crypto.randomUUID()
    localStorage.setItem('client_id', clientId)

    const incomingFiles = {} // key = fileId, value = { meta, chunks }

    function connect() {
      peer = new Peer(clientId)
      peer.on('open', () => {
        if (!hostId) return alert('No host peer id')

        conn = peer.connect(hostId, {
          metadata: { clientId, nick: 'Client' }
        })
        bindConnection()
      })
    }
    function bindConnection() {
      conn.on('open', () => {
        status('connected')
        log('Connected to host')
      })

      let approved = false

      conn.on('data', data => {
        if (typeof data === 'string') {
          const msg = JSON.parse(data)

          if (msg.t === 'status') {
            if (msg.p === 'approved') {
              approved = true
              status('connected')
              log('Host approved connection')
              conn.send(JSON.stringify({ t: 'files', p: 'list' }))
            } else if (msg.p === 'pending') {
              approved = false
              status('waiting for approval')
              log('Waiting for host approval...')
            } else if (msg.p === 'rejected') {
              status('rejected')
              log('Host rejected connection')
              conn.close()
            }
            return
          }

          if (!approved) return

          if (msg.t === 'files') renderFiles(msg.p)

          if (msg.t === 'file:start') {
            incomingFiles[msg.p.id] = { meta: msg.p, chunks: [], received: 0 }
          }

          if (msg.t === 'file:end') {
            const fileData = incomingFiles[msg.p]
            if (fileData) {
              const blob = new Blob(fileData.chunks)
              downloadBlob(blob, fileData.meta.name)
              delete incomingFiles[msg.p]
            }
          }

          if (msg.t === 'file:fail') {
            toast("failed")
            const fileData = incomingFiles[msg.p]
            if (fileData) delete incomingFiles[msg.p]
          }
        } else {
          const u8 = new Uint8Array(data)
          const sep = u8.indexOf(0)
          if (sep === -1) return
          const type = new TextDecoder().decode(u8.slice(0, sep))
          const payload = u8.slice(sep + 1).buffer

          if (type === 'file') {
            const activeFile = Object.values(incomingFiles).find(f => f.meta && f.chunks !== undefined)
            if (activeFile) {
              activeFile.chunks.push(payload)
              activeFile.received += payload.byteLength

              if (conn.open) {
                conn.send(JSON.stringify({
                  t: 'file:ack',
                  p: { id: activeFile.meta.id, offset: activeFile.received }
                }))
              }
            }
          }

        }
      })

      conn.on('close', () => {
        status('disconnected')
        log('Connection closed')
      })

      conn.on('error', err => log('Error:', err))
    }

    function renderFiles(list) {
      filesEl.innerHTML = ''
      list.forEach(f => {
        const row = document.createElement('div')
        row.className = 'file'
        row.innerHTML = `<span>${f.name}</span><small>${(f.size / 1024).toFixed(1)} KB</small>`
        row.onclick = () => {
          if (conn.open) conn.send(JSON.stringify({ t: 'files', p: { get: f.id } }))
        }
        filesEl.appendChild(row)
      })
    }

    function downloadBlob(blob, name) {
      const a = document.createElement('a')
      const url = URL.createObjectURL(blob)
      a.href = url
      a.download = name
      document.body.appendChild(a)
      a.click()
      URL.revokeObjectURL(url)
      a.remove()
      log(`Downloaded ${name}`)
    }


    connect()
  </script>

</body>

</html>